// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol";

// nHomes (nH) v1.0.0
// nH registers homes and offices for users to use as nodes to create profiles
// this contract is a proxy to the profile contract
// this contract is called by a conda enviornment running on a user's computer to create a household node as a profile.
// this node can hold multiple profiles while keeping the profiles private, and the household node public.
// this node can also hold multiple homes as offices, and each home can hold multiple profiles to be used in professional settings
// nodes are used to create profiles
// profiles can be made in a number of ways
    // profiles can be generated by a user's computer, phone, or tablet
    // profiles can be generated automatically by a home or professional node (this is the default) and locked to the user's biometrics
        // in this case, the data from the profile is encrypted and stored locally on the node's computer.
        // this contract can use non-detirministic algorithms to generate a signiture key. using Phoenix these keys can be uploaded to the blockchain to give the user access to their profile
            // this can allow for time delayed access to the data, giving the user time to recover their profile before it is deleted
            // this can also allow for the user to recover their profile if they lose their phone or computer
// it has a function to create a profile node
// it has a function to create a profile node fragment



contract nHomes is Initializable, ERC1155Upgradeable, ERC1155BurnableUpgradeable, ERC1155PausableUpgradeable, OwnableUpgradeable, UUPSUpgradeable, AccessControlUpgradeable, ERC1155SupplyUpgradeable {
    struct Item {
        bytes32[] encryptedItem;
    }
    uint256 public itemID;
    mapping (uint256 => Item) internal items;
    event EncryptionToolsSet(address _encryptionTools);
    bytes32 public constant URI_SETTER_ROLE = keccak256("URI_SETTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    address public ETAddress;
    address public ITAddress;
    address public newOwner;
    address public IDAddress;
    event ItemTrackerSet(address _itemTracker);
    mapping(uint256 => address) public itemOwners;
    address public vaultAddress;
    mapping(uint256 => address) public vaults;
    mapping(uint256 => uint256) public vaultIDs;
    mapping(uint256 => uint256) public vaultBalances;
    event VaultSet(address _vault);
    address public profileAddress;
    mapping(uint256 => uint256) public Profiles;
    mapping(uint256 => uint256) public ProfileIDs;
    mapping(uint256 => uint256) public ProfileBalances;
    event ProfileSet(address _profile);
    // this is the nHome contract address that local clients can use to connect to the server locally
    address public homeAddress;
    mapping(uint256 => uint256) public Homes;
    mapping(uint256 => uint256) public HomeIDs;
    mapping(uint256 => uint256) public HomeBalances;
    event HomeSet(address _home);
    // this is the nWonderland contract addresses that clients can use to connect to the server remotely
    address public officeAddress;
    mapping(uint256 => uint256) public Offices;
    mapping(uint256 => uint256) public OfficeIDs;
    mapping(uint256 => uint256) public OfficeBalances;
    event OfficeSet(address _office);
    // this is the brain instance of the server
    address public nodeAddress;
    mapping(uint256 => uint256) public Nodes;
    mapping(uint256 => uint256) public NodeIDs;
    mapping(uint256 => uint256) public NodeBalances;
    event NodeSet(address _node);

function initialize(address _nodeAddress) public {
        __ERC1155_init("https://ipfs.io/ipfs/");
        __ERC1155Burnable_init();
        __ERC1155Pausable_init();
        __Ownable_init();
        __UUPSUpgradeable_init();
        __AccessControl_init();
        __ERC1155Supply_init();
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(URI_SETTER_ROLE, msg.sender);
        _setupRole(PAUSER_ROLE, msg.sender);
        _setupRole(MINTER_ROLE, msg.sender);
        _setupRole(UPGRADER_ROLE, msg.sender);
        nodeAddress = _nodeAddress;
        // creates an item and sets the owner of the item to this contract and then transfers the vault to the owner of the item
        itemID = 0;
        itemOwners[itemID] = address(this);
        vaultAddress = address(this);
        vaults[itemID] = vaultAddress;
        vaultIDs[itemID] = itemID;
        vaultBalances[itemID] = 1;
        _mint(address(this), itemID, 1, "");
        _safeTransferFrom(address(this), vaultAddress, itemID, 1, "");
        // // creates a profile node and sets the owner of the profile node to this contract and then transfers the profile node to the owner of the item
        // // this is transfered to a nWonderland contract that is deployed by the user who created the profile node by signing a message with their private key 
        // // over to a wallet that is owned by the user
        // itemID = 1;
        // itemOwners[itemID] = address(this);
        // nodeAddress = address(this);
        // Nodes[itemID] = nodeAddress;
        // NodeIDs[itemID] = itemID;
        // NodeBalances[itemID] = 1;
        // _mint(address(this), itemID, 1, "");
        // _safeTransferFrom(address(this), nodeAddress, itemID, 1, "");
    }
    // this function creates a delegate call to the profile contract to set the encryption tools, the item tracker, the Item Distributor, and then creates a vault and then 
    // creates an item and sets the owner of the item to this contract and then transfers the vault to the owner of the item

    function activateNode()public{
        // create a delegate call to the profile contract to make a profile
        (bool success, bytes memory result) = profileAddress.call(abi.encodeWithSignature("createVault()"));
        require(success, "Delegate call failed");
    }

    // 1. create a profile
    // 2. add 3 vaults to the profile
    // 3. add homes to vault 1 (homes are the local clients)
    // 4. add offices to vault 2 (offices are the remote clients)
    // 5. add nodes to vault 3 (nodes are trades with a wonderland contract)


    // this function creates an item using ET, creates a set of blank NFTs using IT, creates a random list of numbers using ID, and encrypts all three of them within a vault.
    // The vault is then sent returned to the user's computer and the key is set a time delayed digital signature key that is cleared after a set amount of time or 
    // a certain number of transactions have been made giving the processor time to verify the data and upload it to the blockchain.
        // Through an MVP reward oracle, the confidence of a user owning a profile will be increased over time as the IT fills out data about the item.
        // in this case, the item is a profile, so the IT nfts will be filled with data about the profile.
        // over time, there will be ten million pictures of the user in different settings, and the user will be able to use this data to prove ownership of the profile.
        // at 60fps, this will take 1.9 days to fill out the data. These 10 million frames will be used to create 3d models of the user in different settings and in different poses 
        // and eventually the entire profile will just be a high resolution 3d model of the user, all other data that is not needed can be saved in other vaults under the profile.

    
    
            function setURI(string memory newuri) public onlyRole(URI_SETTER_ROLE) {
        _setURI(newuri);
    }

    function pause() public onlyRole(PAUSER_ROLE) {
        _pause();
    }

    function unpause() public onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    function mint(address account, uint256 id, uint256 amount, bytes memory data)
        public
        onlyRole(MINTER_ROLE)
    {
        _mint(account, id, amount, data);
    }

    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
        public
        onlyRole(MINTER_ROLE)
    {
        _mintBatch(to, ids, amounts, data);
    }

    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
        internal
        whenNotPaused
        override(ERC1155PausableUpgradeable, ERC1155Upgradeable, ERC1155SupplyUpgradeable)
    {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }

    function _authorizeUpgrade(address newImplementation)
        internal
        onlyRole(UPGRADER_ROLE)
        override
    {}

    // The following functions are overrides required by Solidity.

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC1155Upgradeable, AccessControlUpgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }


}